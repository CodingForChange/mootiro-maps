#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals  # unicode by default

import simplejson
from datetime import datetime, timedelta

from django.db import models
from django.contrib.gis.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.translation import pgettext

from komoo_resource.models import Resource


class Update(models.Model):
    """An update generated by users interactions with komoo."""

    _names = models.CharField(max_length=2048, null=False)
    _slugs = models.CharField(max_length=2048, null=False)
    _links = models.CharField(max_length=2048, null=False)
    _users = models.CharField(max_length=2048, null=False)
    _communities_names = models.CharField(max_length=2048)
    _communities_slugs = models.CharField(max_length=2048)

    object_id = models.IntegerField(null=False, db_index=True)
    object_type = models.CharField(max_length=32, null=False, db_index=True)
    
    date = models.DateTimeField(auto_now=True)
    comments_count = models.IntegerField(null=True)

    # update type
    ADD = "A"
    EDIT = "E"
    DISCUSSION = "D"
    TYPES = {
        "A": "added",
        "E": "edited",
        "D": "discussed",
    }
    type = models.CharField(max_length=1, null=False, db_index=True,
            choices=tuple(TYPES.items()))

    # TODO: refactor those methods below into a JsonField class
    @property
    def instances(self):
        names = simplejson.loads(self._names)
        slugs = simplejson.loads(self._slugs)
        links = simplejson.loads(self._links)
        return zip(names, slugs, links)
    @instances.setter
    def instances(self, l):
        self._names = simplejson.dumps([i.name for i in l])
        slugs = [(i.slug if type(i) != Resource else i.id) for i in l]
        self._slugs = simplejson.dumps(slugs)
        self._links = simplejson.dumps([i.view_url for i in l])
    @property
    def instance(self):
        first = self.instances[0]
        return dict(name=first[0], slug=first[1], link=first[2])

    @property
    def users(self):
        return simplejson.loads(self._users)
    @users.setter
    def users(self, l):
        self._users = simplejson.dumps(l)
    @property
    def user(self):
        return self.users[0]

    @property
    def communities(self):
        if not self._communities_names:
            return []
        names = simplejson.loads(self._communities_names)
        slugs = simplejson.loads(self._communities_slugs)
        return [dict(name=z[0], slug=z[1]) for z in zip(names, slugs)]
    @communities.setter
    def communities(self, l):
        self._communities_names = simplejson.dumps([c.name for c in l])
        self._communities_slugs = simplejson.dumps([c.slug for c in l])

    @classmethod
    def get_recent_discussion_for(cls, obj):
        one_day_ago = datetime.now() - timedelta(days=1)
        u = Update.objects.filter(object_id=obj.id, type=cls.DISCUSSION,
            object_type=obj._meta.verbose_name, date__gt=one_day_ago)
        return u[0] if u else None

    def __unicode__(self):
        return unicode(self.title)

    @property
    def name(self):
        return self.title

    @property
    def image(self):
        return "img/updates-page/{}-{}.png" \
                    .format(self.object_type, self.TYPES[self.type])

    @property
    def readable_type(self):
        key_str = "{0} {1}".format(self.object_type, self.TYPES[self.type])
        tr_dict = {
            "community added":     _("community added"),
            "community edited":    _("community edited"),
            "community discussed": _("community discussed"),

            "need added":     _("need added"),
            "need edited":    _("need edited"),
            "need discussed": _("need discussed"),

            "proposal added":     _("proposal added"),
            "proposal edited":    _("proposal edited"),
            "proposal discussed": _("proposal discussed"),

            "organization added":     _("organization added"),
            "organization edited":    _("organization edited"),
            "organization discussed": _("organization discussed"),

            "resource added":     _("resource added"),
            "resource edited":    _("resource edited"),
            "resource discussed": _("resource discussed"),

            "investment added":     _("investment added"),
            "investment edited":    _("investment edited"),
            "investment discussed": _("investment discussed"),
        }
        return tr_dict[key_str]


class News(models.Model):
    """A news update to be shown in frontpage."""

    class Meta:
        verbose_name = "news"
        verbose_name_plural = "news"

    title = models.CharField(max_length=256, null=True, blank=True)
    title_link = models.CharField(max_length=512, null=True, blank=True)
    description = models.CharField(max_length=512, null=True, blank=True)
    date = models.DateField(null=False)

    def __unicode__(self):
        return "{} on {}".format((self.title or self.description or "blank"),
                            self.date)


# How does this works? Isn't it a circular dependency???
import signals
